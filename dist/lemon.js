(function(window) {
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  }
}
window.indexOf = Array.prototype.indexOf;
if (typeof Object.assign != 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) { // .length of function is 2
      'use strict';
      if (target == null) { // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
(function(){
  var target_time = 0;
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback) {
      var current_time = +new Date;
      target_time = Math.max(target_time + 16, current_time);
      var timeout_cb = function() { callback(+new Date); }
      return window.setTimeout(timeout_cb, target_time - current_time);
    };
  }
})();
// Generated by CoffeeScript 1.12.7
if (window.lemon == null) {
  window.lemon = {};
}

if (window.site == null) {
  window.site = {};
}

if (window.page == null) {
  window.page = {};
}

if (lemon.Components == null) {
  lemon.Components = {};
}

if (lemon.Specs == null) {
  lemon.Specs = {};
}
// Generated by CoffeeScript 1.12.7
var slice = [].slice;

lemon.Component = (function() {
  Component.prototype._defaults = {
    "class": '',
    computed: {},
    contents: null,
    data: {},
    lifecycle: {},
    methods: {},
    mounted: false,
    routes: {},
    template: function() {},
    watch: {}
  };

  function Component(spec, data, contents) {
    var attrs, base, base1, base2, fn, fn1, k, key, name, ref1, ref2, v;
    if (!(this instanceof lemon.Component)) {
      attrs = {};
      for (k in data) {
        v = data[k];
        if (k === 'id' || k === 'class') {
          attrs[k] = v;
        }
        if ((k === 'style' || k === 'data' || k === 'on' || k === 'bind') || ((ref1 = k[0]) === '$' || ref1 === '_')) {
          attrs[k] = v;
          delete data[k];
        }
      }
      attrs['lemon-component'] = spec["package"] + "." + spec.name;
      if (contents) {
        attrs['lemon-contents'] = contents;
      }
      attrs['lemon-data'] = data;
      tag(spec.element || 'div', attrs);
      return;
    }
    spec = Object.assign({}, this._defaults, spec);
    for (k in spec) {
      v = spec[k];
      this["_" + k] = v;
    }
    this._hook('beforeCreate');
    this._data = Object.assign({}, spec.data, data);
    this._contents = contents || spec.contents || function() {};
    if (this._id == null) {
      this._id = this._data.id;
    }
    if (this._class == null) {
      this._class = this._data["class"];
    }
    this._uid = this._id || this._data.id || lemon.uid();
    this._ref = this._data.ref;
    Object.defineProperty(this, 'el', {
      get: function() {
        return this._el;
      }
    });
    lemon.Components[this._uid] = this;
    if (this._ref == null) {
      this._ref = this._uid;
    }
    if (this.el) {
      if (typeof (base = this.el).setAttribute === "function") {
        base.setAttribute('lemon-uid', this._uid);
      }
      if (this._ref) {
        if (typeof (base1 = this.el).setAttribute === "function") {
          base1.setAttribute('lemon-ref', this._ref);
        }
      }
      if (this._id) {
        if (typeof (base2 = this.el).setAttribute === "function") {
          base2.setAttribute('id', this._id);
        }
      }
      if (this._class) {
        lemon.addClass(this.el, this._class);
      }
    }
    ref2 = this._methods;
    for (name in ref2) {
      fn = ref2[name];
      if (this[name] == null) {
        this[name] = fn.bind(this);
      }
    }
    this._children = [];
    this._refs = {};
    this._listeners = [];
    for (key in this._data) {
      this._observe(key);
    }
    fn1 = (function(_this) {
      return function(key) {
        var self;
        self = _this;
        Object.defineProperty(self, key, {
          get: function() {
            return self._apply(self._computed[key]);
          }
        });
        return Object.defineProperty(_this._data, key, {
          get: function() {
            return self._apply(self._computed[key]);
          }
        });
      };
    })(this);
    for (key in this._computed) {
      fn1(key);
    }
    this._hook('created');
  }


  /*
   * PRIVATE METHODS
   */

  Component.prototype._addEventListener = function(el, event, handler) {
    var i, len, ref1, ref2, x;
    if (!handler) {
      ref1 = [this.el, el, event], el = ref1[0], event = ref1[1], handler = ref1[2];
    }
    ref2 = this._listeners;
    for (i = 0, len = ref2.length; i < len; i++) {
      x = ref2[i];
      if (x[0] === el && x[1] === event) {
        return;
      }
    }
    this._listeners.push([el, event, handler]);
    return el.addEventListener(event, handler);
  };

  Component.prototype._apply = function(fn, args) {
    if (typeof fn === 'string') {
      if (this._methods[fn]) {
        return this._methods[fn].apply(this, args);
      } else {
        return this._warn(fn + " is not defined");
      }
    } else if (typeof fn === 'function') {
      return fn.apply(this, args);
    } else {
      return true;
    }
  };

  Component.prototype._bind = function(el, key, options) {
    var attr, fn, node, prop, results, rules, value;
    if (key == null) {
      key = '';
    }
    if (options == null) {
      options = {};
    }
    if (key) {
      key = "='" + key + "'";
    }
    rules = {
      'src': function(node, value) {
        return node.setAttribute('src', value);
      },
      'href': function(node, value) {
        return node.setAttribute('href', value);
      },
      'text': function(node, value) {
        return node.textContent = "" + value;
      },
      'html': function(node, value) {
        return node.innerHTML = "" + value;
      },
      'on': (function(_this) {
        return function(node, value, options) {
          node.innerHTML = '';
          return _this._bindListRule(node, [value], options);
        };
      })(this),
      'list': this._bindListRule.bind(this)
    };
    results = [];
    for (prop in rules) {
      fn = rules[prop];
      attr = "lemon-bind:" + prop;
      results.push((function() {
        var i, len, ref1, results1;
        ref1 = this._find(el, "[" + (attr.replace(':', '\\:')) + key + "]");
        results1 = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          node = ref1[i];
          value = this[node.getAttribute(attr)];
          results1.push(fn(node, value, options));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  Component.prototype._bindListRule = function(node, items, options) {
    var args, child, children, comp, data, el, fn, i, item, j, l, len, len1, len2, len3, m, method, ref1, ref2, ref3, results, results1, results2, results3, temp, template;
    if (options == null) {
      options = {};
    }
    method = options.method, args = options.args;
    temp = node.getAttribute("lemon-bind:template");
    comp = node.getAttribute("lemon-bind:component");
    fn = lemoncup._data[temp] || lemoncup._data[comp];
    data = this._data;
    if (temp) {
      template = function(arg) {
        var data, fn, item;
        fn = arg.fn, item = arg.item, data = arg.data;
        return div({
          'lemon-data': item
        }, function() {
          return fn(item, data);
        });
      };
    } else {
      template = function(arg) {
        var data, fn, item;
        fn = arg.fn, item = arg.item, data = arg.data;
        return fn(item, data);
      };
    }
    switch (method) {
      case 'pop':
        if (node.lastChild) {
          return node.removeChild(node.lastChild);
        }
        break;
      case 'push':
      case void 0:
        if (!method) {
          node.innerHTML = null;
        }
        ref1 = args || items;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          item = ref1[i];
          el = this._render({
            data: {
              fn: fn,
              item: item,
              data: data
            },
            el: node,
            method: 'append',
            template: template
          });
          results.push(this._hydrate(el));
        }
        return results;
        break;
      case 'reverse':
        ref2 = node.children;
        results1 = [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          el = ref2[j];
          results1.push(node.insertBefore(el, node.firstChild));
        }
        return results1;
        break;
      case 'shift':
        if (node.firstChild) {
          return node.removeChild(node.firstChild);
        }
        break;
      case 'sort':
        fn = args[0] || function(a, b) {
          if (a < b) {
            return -1;
          } else {
            return 1;
          }
        };
        children = (function() {
          var l, len2, ref3, results2;
          ref3 = node.children;
          results2 = [];
          for (l = 0, len2 = ref3.length; l < len2; l++) {
            child = ref3[l];
            results2.push(child);
          }
          return results2;
        })();
        children = children.sort(function(a, b) {
          var value_a, value_b;
          value_a = lemoncup._data[a.getAttribute('lemon-data')];
          value_b = lemoncup._data[b.getAttribute('lemon-data')];
          return fn(value_a, value_b);
        });
        results2 = [];
        for (l = 0, len2 = children.length; l < len2; l++) {
          child = children[l];
          results2.push(node.appendChild(child));
        }
        return results2;
        break;
      case 'splice':
        if (args[0] === 0 && args.length === 1) {
          return node.innerHTML = '';
        } else {
          return this._warn("splice not supported");
        }
        break;
      case 'unshift':
        ref3 = args.reverse();
        results3 = [];
        for (m = 0, len3 = ref3.length; m < len3; m++) {
          item = ref3[m];
          el = this._render({
            data: {
              fn: fn,
              item: item,
              data: data
            },
            el: node,
            method: 'prepend',
            template: template
          });
          results3.push(this._hydrate(el));
        }
        return results3;
    }
  };

  Component.prototype._destroy = function() {
    var child, i, len, ref1, ref2;
    this._hook('beforeDestroy');
    lemon.off('url_change', this._onUrlChange);
    this._removeEventListeners();
    ref1 = this._children;
    for (i = 0, len = ref1.length; i < len; i++) {
      child = ref1[i];
      child._destroy();
    }
    delete lemon.Components[this._uid];
    if ((ref2 = this.el.parentNode) != null) {
      ref2.removeChild(this.el);
    }
    return this._hook('destroyed');
  };

  Component.prototype._find = function(target, selector) {
    var el, elements, i, is_mine, len, mine, parent, ref1;
    if (typeof target === 'string') {
      ref1 = [this.el, target], target = ref1[0], selector = ref1[1];
    }
    elements = target.querySelectorAll(selector);
    mine = [];
    for (i = 0, len = elements.length; i < len; i++) {
      el = elements[i];
      is_mine = true;
      parent = el.parentNode;
      while (parent !== target) {
        if (parent.getAttribute('lemon-component')) {
          is_mine = false;
          break;
        }
        parent = parent.parentNode;
      }
      if (is_mine) {
        mine.push(el);
      }
    }
    return mine;
  };

  Component.prototype._hook = function(name) {
    return this._apply(this._lifecycle[name]);
  };

  Component.prototype._hydrate = function(el, opt) {
    var component, event, fn1, i, j, key, l, len, len1, len2, len3, len4, link, links, m, n, node, nodes, ref, ref1, ref2, ref3, results, uid;
    if (opt == null) {
      opt = {};
    }
    if (el == null) {
      el = this.el;
    }
    ref1 = lemon.browser_events;
    for (i = 0, len = ref1.length; i < len; i++) {
      event = ref1[i];
      key = "lemon-on:" + event;
      nodes = this._find(el, "[" + (key.replace(':', '\\:')) + "]");
      fn1 = (function(_this) {
        return function(node, event, key) {
          return _this.addEventListener(node, event, function(e) {
            var fn, value;
            value = node.getAttribute(key);
            fn = lemoncup._data[value] || _this[value];
            return _this._apply(fn, [e]);
          });
        };
      })(this);
      for (j = 0, len1 = nodes.length; j < len1; j++) {
        node = nodes[j];
        fn1(node, event, key);
      }
    }
    ref2 = this._find(el, "[lemon-component]");
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      node = ref2[l];
      component = lemon.loadElement(node, opt);
      component._parent = this;
      if (component) {
        this._children.push(component);
      }
    }
    ref3 = this._find(el, "[lemon-ref]");
    for (m = 0, len3 = ref3.length; m < len3; m++) {
      node = ref3[m];
      ref = node.getAttribute('lemon-ref');
      uid = node.getAttribute('lemon-uid');
      this._refs[ref] = uid ? lemon.get(uid) : node;
      this[ref] = this._refs[ref];
    }
    this._bind(el, null, opt);
    links = this._find(el, "a[href^='/'],a[href^='?'],a[href^='#']");
    results = [];
    for (n = 0, len4 = links.length; n < len4; n++) {
      link = links[n];
      results.push((function(_this) {
        return function(link) {
          return _this.addEventListener(link, 'click', function(e) {
            e.preventDefault();
            return lemon.route(link.getAttribute('href'));
          });
        };
      })(this)(link));
    }
    return results;
  };

  Component.prototype._mount = function(opt) {
    if (opt == null) {
      opt = {};
    }
    if (opt.render == null) {
      opt.render = true;
    }
    if (this.el.innerHTML === '') {
      opt.render = true;
    }
    this._hook('beforeMount');
    this._removeEventListeners();
    if (opt.render) {
      this._render({
        el: this.el,
        template: this._template,
        data: this._data,
        contents: this._contents
      });
    }
    this._hydrate(this.el, opt);
    this._hook('mounted');
    this._startRouter();
    return this._mounted = true;
  };

  Component.prototype._observe = function(key) {
    Object.defineProperty(this, key, {
      get: function() {
        return this._data[key];
      },
      set: function(value) {
        if (this._data[key] === value) {
          return;
        }
        this._data[key] = value;
        this._apply(this._watch[key], [value]);
        this._bind(this.el, key);
        if (Array.isArray(value)) {
          return this._observeArray(key);
        }
      }
    });
    if (Array.isArray(this._data[key])) {
      return this._observeArray(key);
    }
  };

  Component.prototype._observeArray = function(key) {
    var self;
    if (this._data[key]._observer) {
      return;
    }
    self = this;
    return Object.defineProperty(this._data[key], '_observer', {
      enumerable: false,
      value: function(arg) {
        var args, method;
        method = arg.method, args = arg.args;
        return self._bind(self.el, key, {
          method: method,
          args: args
        });
      }
    });
  };

  Component.prototype._removeEventListeners = function() {
    var el, handler, i, len, listener, name, ref1;
    ref1 = this._listeners;
    for (i = 0, len = ref1.length; i < len; i++) {
      listener = ref1[i];
      el = listener[0], name = listener[1], handler = listener[2];
      el.removeEventListener(name, handler);
    }
    return this._listeners = [];
  };

  Component.prototype._render = function(options) {
    var contents, data, el, html, method, template;
    el = options.el, method = options.method, template = options.template, data = options.data, contents = options.contents;
    html = lemoncup.render(template, data, contents);
    return lemon.updateDOMElement(el, method, html);
  };

  Component.prototype._startRouter = function() {
    var k, onUrlChange;
    if (this._onUrlChange) {
      return;
    }
    if (((function() {
      var results;
      results = [];
      for (k in this._routes) {
        results.push(k);
      }
      return results;
    }).call(this)).length === 0) {
      return;
    }
    onUrlChange = function() {
      var match;
      match = lemon.checkRoutes(this._routes);
      if (match) {
        return this._apply(match.action, [match]);
      }
    };
    this._onUrlChange = onUrlChange.bind(this);
    lemon.on('url_change', this._onUrlChange);
    return this._onUrlChange();
  };

  Component.prototype._warn = function() {
    return console.warn.apply(console, ["[" + this._package + "." + this._name + "]"].concat(slice.call(arguments)));
  };


  /*
   * PUBLIC METHODS
   */

  Component.prototype.addEventListener = function() {
    return this._addEventListener.apply(this, arguments);
  };

  Component.prototype.find = function() {
    return this._find.apply(this, arguments);
  };

  Component.prototype.findOne = function() {
    return this._find.apply(this, arguments)[0];
  };

  Component.prototype.hydrate = function() {
    return this._hydrate.apply(this, arguments);
  };

  Component.prototype.mount = function() {
    return this._mount.apply(this, arguments);
  };

  Component.prototype.render = function() {
    return this._render.apply(this, arguments);
  };

  Component.prototype.warn = function() {
    return this._warn.apply(this, arguments);
  };

  return Component;

})();
// Generated by CoffeeScript 1.12.7

/*
 * Function for adding a class to a dom element
 */
lemon.addClass = function(el, class_names) {
  var class_name, i, len, ref, results;
  if (!el) {
    return;
  }
  ref = class_names.split(' ');
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    class_name = ref[i];
    if (el.classList) {
      results.push(el.classList.add(class_name));
    } else {
      results.push(el.className += ' ' + class_name);
    }
  }
  return results;
};
// Generated by CoffeeScript 1.12.7

/*
 * lemon
 */
lemon.ajax = function(options, next) {
  var data, headers, k, method, qs, req, timeout, url, v;
  data = options.data, headers = options.headers, method = options.method, qs = options.qs, timeout = options.timeout, url = options.url;
  if (method == null) {
    method = 'GET';
  }
  if (headers == null) {
    headers = {};
  }
  if (typeof data === 'object') {
    headers['Content-Type'] = 'application/json';
    data = JSON.stringify(data);
  }
  req = new XMLHttpRequest();
  if (qs) {
    url += "?" + ((function() {
      var results;
      results = [];
      for (k in qs) {
        v = qs[k];
        results.push(encodeURI(k + "=" + v));
      }
      return results;
    })()).join('&');
  }
  if (timeout) {
    req.timeout = timeout;
    req.ontimeout = function(e) {
      return next(e);
    };
  }
  req.open(method, url);
  for (k in headers) {
    v = headers[k];
    req.setRequestHeader(k, v);
  }
  req.onreadystatechange = function() {
    var body, content_type;
    if (req.readyState === 4 && (req.status >= 200 && req.status < 400)) {
      body = req.responseText;
      content_type = req.getResponseHeader('Content-Type');
      if (content_type != null ? content_type.match(/json/) : void 0) {
        body = JSON.parse(body);
      }
      return next(null, body);
    } else if (req.readyState === 4) {
      return next({
        status: req.status,
        error: req.statusText
      });
    }
  };
  req.onerror = function(err) {
    return next(err);
  };
  return req.send(data);
};
// Generated by CoffeeScript 1.12.7
var fn, i, len, method, methods,
  slice = [].slice;

methods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

fn = function(method) {
  var _fn;
  _fn = Array.prototype[method];
  return Array.prototype[method] = function() {
    var args, result;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    result = _fn.apply(this, arguments);
    if (typeof this._observer === "function") {
      this._observer({
        method: method,
        args: args
      });
    }
    return result;
  };
};
for (i = 0, len = methods.length; i < len; i++) {
  method = methods[i];
  fn(method);
}
// Generated by CoffeeScript 1.12.7

/*
 * Function for computing the true scrolling height of the body
 */
lemon.bodyHeight = function() {
  var body, height, html;
  body = document.body;
  html = document.documentElement;
  height = Math.max.apply(Math, [body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight]);
  return height;
};
// Generated by CoffeeScript 1.12.7

/*
 * List of browser methods available in the current browser
 * for adding event listeners on
 */
var e;

lemon.browser_events = [];

for (e in document) {
  if (typeof document[e] !== "function" && (e != null ? e.substring(0, 2) : void 0) === "on") {
    lemon.browser_events[lemon.browser_events.length] = e.replace('on', '');
  }
}
// Generated by CoffeeScript 1.12.7

/*
 * Function to check whether a routing pattern matches
 * the current url of the page
 *
 * The result contains the page details: hash, href, params, pathname, query
 */
lemon.checkRoute = function(pattern) {
  var hash, href, i, j, k, key, l, len, matches, names, params, pathname, query, re, re_escape, re_exp_param, re_named_exp_param, re_named_param, re_splat_param, ref, ref1, ref2, search, v, val, x;
  href = location.href, hash = location.hash, pathname = location.pathname, search = location.search;
  search = search.replace('?', '');
  hash = hash.replace('#', '');
  pathname = pathname.replace(/.\/$/, '');
  pattern = pattern.replace(/\*$/, '*rest');
  pattern = pattern.replace(/\/$/, '');
  if (pattern[0] !== '/') {
    pattern = "/" + pattern;
  }
  re_exp_param = /\/\((.*?)\)(\/|\b)/g;
  re_named_exp_param = /\/\((.*?)\):(\w+)/g;
  re_named_param = /\/[:](\w+)/g;
  re_splat_param = /\/[*](\w+)/g;
  re_escape = /[{}?.,\\\^$#\s]/g;
  names = [];
  re = pattern;
  re = re.replace(re_escape, "\\$&");
  re = re.replace(re_exp_param, function(_, exp, char) {
    return "/(?:" + exp + ")" + (char || '');
  });
  re = re.replace(re_named_exp_param, function(_, exp, name) {
    names.push(name);
    return "/(" + exp + ")";
  });
  re = re.replace(re_named_param, function(_, name) {
    names.push(name);
    return '/([^/]*)';
  });
  re = re.replace(re_splat_param, function(_, name) {
    names.push(name);
    return '/?(.*)';
  });
  re = new RegExp("^" + re + "$");
  matches = re.exec(pathname);
  if (!matches) {
    return null;
  }
  params = {};
  for (i = j = 0, ref = names.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    key = names[i];
    val = matches[i + 1];
    params[key] = val;
  }
  query = {};
  ref1 = search.split('&');
  for (l = 0, len = ref1.length; l < len; l++) {
    x = ref1[l];
    ref2 = x.split('='), k = ref2[0], v = ref2[1];
    if (v != null) {
      query[k] = v;
    }
  }
  return {
    pathname: pathname,
    params: params,
    query: query,
    hash: hash,
    href: href,
    search: search
  };
};
// Generated by CoffeeScript 1.12.7

/*
 * Function to check a given set of routes and return
 * the first one that matches the current url, if any.
 *
 * The result contains the page details: hash, href, params, pathname, query
 * As well as the pattern of the route that was matched, and the action to take
 */
lemon.checkRoutes = function(routes) {
  var action, pattern, result;
  for (pattern in routes) {
    action = routes[pattern];
    result = lemon.checkRoute(pattern);
    if (result) {
      result.action = action;
      result.pattern = pattern;
      return result;
    }
  }
  return null;
};
// Generated by CoffeeScript 1.12.7

/*
 * Function to deep copy an object
 */
lemon.copy = function(obj) {
  var copy, i, key, len, val;
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  if (obj.nodeType) {
    return obj;
  }
  if (Array.isArray(obj)) {
    copy = [];
    for (i = 0, len = obj.length; i < len; i++) {
      val = obj[i];
      copy.push(lemon.copy(val));
    }
    return copy;
  }
  if (obj instanceof Object) {
    copy = {};
    for (key in obj) {
      val = obj[key];
      copy[key] = lemon.copy(val);
    }
    return copy;
  }
  return null;
};
// Generated by CoffeeScript 1.12.7
lemon.define = function(key) {
  var name, pkg, ref;
  ref = key.split('.'), pkg = ref[0], name = ref[1];
  if (window[pkg] == null) {
    window[pkg] = {};
  }
  return window[pkg][name] = function(data, contents) {
    var spec;
    spec = lemon.Specs[pkg + "." + name];
    if (this instanceof window[pkg][name]) {
      return new lemon.Component(spec, data, contents);
    } else {
      return lemon.Component(spec, data, contents);
    }
  };
};
// Generated by CoffeeScript 1.12.7
var slice = [].slice;

lemon.events = {};

lemon.emit = function() {
  var args, event, handler, i, len, ref, results;
  event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  ref = lemon.events[event] || [];
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    handler = ref[i];
    results.push(handler.apply(null, args));
  }
  return results;
};

lemon.on = function(event, handler) {
  var base;
  if ((base = lemon.events)[event] == null) {
    base[event] = [];
  }
  return lemon.events[event].push(handler);
};

lemon.once = function(event, handler) {
  var base, wrapper;
  if ((base = lemon.events)[event] == null) {
    base[event] = [];
  }
  wrapper = (function(_this) {
    return function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      lemon.off(event, wrapper);
      return handler.apply(null, args);
    };
  })(this);
  return lemon.events[event].push(wrapper);
};

lemon.off = function(event, handler) {
  var base;
  if (handler == null) {
    handler = null;
  }
  if ((base = lemon.events)[event] == null) {
    base[event] = [];
  }
  return lemon.events[event] = lemon.events[event].filter(function(fn) {
    return handler !== null && fn !== handler;
  });
};
// Generated by CoffeeScript 1.12.7
lemon.get = function(id) {
  return lemon.Components[id];
};
// Generated by CoffeeScript 1.12.7

/*
 * Function for checking if an element has a class
 */
lemon.hasClass = function(el, class_name) {
  if (!el) {
    return;
  }
  if (el.classList) {
    return el.classList.contains(class_name);
  } else {
    return new RegExp('(^| )' + class_name + '( |$)', 'gi').test(el.className);
  }
};
// Generated by CoffeeScript 1.12.7
var fn, i, len, method, ref;

if (typeof history !== "undefined" && history !== null ? history.pushState : void 0) {
  ref = ['pushState', 'replaceState'];
  fn = function(method) {
    var _function;
    _function = history[method];
    return history[method] = function() {
      var result;
      result = _function.apply(history, arguments);
      lemon.updatePageData();
      lemon.emit("url_change", page);
      return result;
    };
  };
  for (i = 0, len = ref.length; i < len; i++) {
    method = ref[i];
    fn(method);
  }
  window.addEventListener('popstate', function(e) {
    lemon.updatePageData();
    return lemon.emit("url_change", page);
  });
}
// Generated by CoffeeScript 1.12.7

/*
 * load all top-level components
 */
lemon.init = function() {
  var _render, component, key, ref;
  _render = ((ref = page.data) != null ? ref._render : void 0) || false;
  lemon.updatePageData();
  for (key in lemon.Specs) {
    lemon.define(key);
  }
  component = new lemon.Component({
    id: 'document',
    el: document
  });
  return component._hydrate(document, {
    render: _render
  });
};
// Generated by CoffeeScript 1.12.7

/*
 * Function to load a component from a dom element
 * Any dom element containing the lemon-component attribute
 * can be used. This function will load the component spec
 * then create the component using lemon-data and lemon-contents
 * as input parameters.
 * component loader
 */
lemon.loadElement = function(el, opt) {
  var component, contents, data, lcomp, lcontents, ldata, spec;
  if (el._component) {
    return;
  }
  lcomp = el.getAttribute('lemon-component');
  ldata = el.getAttribute('lemon-data');
  lcontents = el.getAttribute('lemon-contents');
  spec = lemon.Specs[lcomp];
  if (!spec) {
    return console.warn(lcomp + " is not a defined component");
  }
  spec = lemon.copy(spec);
  spec.el = el;
  data = lemoncup._data[ldata];
  contents = lemoncup._data[lcontents];
  component = new lemon.Component(spec, data, contents);
  component.mount(opt);
  el._component = component;
  return component;
};
// Generated by CoffeeScript 1.12.7

/*
 * Function to find a dom elements location in the browser/window
 * Includes standard getBoundingClientRect() properties, as well
 * as _top and _bottom which specify the elements distance to the
 * top and bottom of the current viewport.
 */
lemon.offset = function(el) {
  var rect;
  rect = el.getBoundingClientRect();
  rect._top = Math.max(0, rect.top);
  rect._bottom = Math.max(0, window.innerHeight - rect.top - rect.height);
  return rect;
};
// Generated by CoffeeScript 1.12.7

/*
 * Function for removing a class to a dom element
 */
lemon.removeClass = function(el, class_names) {
  var class_name, i, len, re, ref, results;
  if (!el) {
    return;
  }
  ref = class_names.split(' ');
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    class_name = ref[i];
    if (el.classList) {
      results.push(el.classList.remove(class_name));
    } else {
      re = new RegExp("(^|\\b)" + class_name + "(\\b|$)", 'gi');
      results.push(el.className = el.className.replace(re, ' '));
    }
  }
  return results;
};
// Generated by CoffeeScript 1.12.7

/*
 * Function for programmatic page changes.
 */
lemon.route = function(url) {
  var href, pathname;
  pathname = location.pathname, href = location.href;
  if (url === pathname || url === href) {
    return;
  }
  if (history.pushState) {
    history.pushState(null, null, url);
  } else {
    document.location = url;
  }
  return false;
};
// Generated by CoffeeScript 1.12.7

/*
 * Function for scrolling the window to a specific element
 */
lemon.scrollTo = function(el, duration, offset) {
  var diff, start, step, y;
  if (duration == null) {
    duration = 800;
  }
  if (offset == null) {
    offset = 20;
  }
  y = window.scrollY;
  diff = el.getBoundingClientRect().top - offset;
  start = null;
  step = function(timestamp) {
    var percent, time;
    if (start == null) {
      start = timestamp;
    }
    time = timestamp - start;
    percent = Math.min(time / duration, 1);
    if (percent < .5) {
      percent = 4 * Math.pow(percent, 3);
    } else {
      percent = (percent - 1) * (2 * percent - 2) * (2 * percent - 2) + 1;
    }
    window.scrollTo(0, y + diff * percent);
    if (time < duration) {
      return window.requestAnimationFrame(step);
    }
  };
  return window.requestAnimationFrame(step);
};
// Generated by CoffeeScript 1.12.7

/*
 * Function for toggling a class name on an element
 */
lemon.toggleClass = function(el, class_name) {
  if (!el) {
    return;
  }
  if (lemon.hasClass(el, class_name)) {
    return lemon.removeClass(el, class_name);
  } else {
    return lemon.addClass(el, class_name);
  }
};
// Generated by CoffeeScript 1.12.7

/*
 * Function for generating a unique identifier
 */
lemon.uid = function() {
  return "_" + (++lemon.uid.n);
};

lemon.uid.n = 0;
// Generated by CoffeeScript 1.12.7

/*
 * Function for updating the content of a dom element. The additional
 * content and be prepended/appended to the elements children, or
 * can replace the innerHTML of the element.
 */
lemon.updateDOMElement = function(el, method, html) {
  var div;
  switch (method) {
    case 'append':
      div = document.createElement('div');
      div.innerHTML = html;
      el.appendChild(div.firstChild);
      return el.lastChild;
    case 'prepend':
      div = document.createElement('div');
      div.innerHTML = html;
      el.insertBefore(div.firstChild, el.firstChild);
      return el.firstChild;
    default:
      el.innerHTML = html;
      return el;
  }
};
// Generated by CoffeeScript 1.12.7

/*
 * Check the current route and update window.page data
 */
lemon.updatePageData = function() {
  var hash, href, pathname, query, ref;
  ref = lemon.checkRoute('*'), hash = ref.hash, href = ref.href, query = ref.query, pathname = ref.pathname;
  page.data = site.data[pathname];
  page.hash = hash;
  page.href = href;
  page.markdown = site.markdown[pathname];
  page.pathname = pathname;
  return page.query = query;
};
// Generated by CoffeeScript 1.12.7
(function() {
  var i, len, name, ref, results;
  ref = ['resize', 'scroll'];
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    name = ref[i];
    results.push((function(name) {
      var _event, _running;
      _running = false;
      _event = e;
      return window.addEventListener(name, function(e) {
        _event = e;
        if (!_running) {
          _running = true;
          return window.requestAnimationFrame(function() {
            lemon.emit(name, _event);
            return _running = false;
          });
        }
      });
    })(name));
  }
  return results;
})();
})(window)
